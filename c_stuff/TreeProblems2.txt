/* Binary Tree to DLL */
struct node* bst_to_dll2(struct node* root)
{
	if(root==null)
		return null;
	fixPrevPtr(root);
	return fixNextPtr(root);
}
void fixPrevPtr(struct node* root)
{
	struct node* prev=null;
	if(root==null)
		return;
	fixPrevPtr(root->left);
	root->left=prev;
	prev=root;
	fixPrevPtr(root->right);
}
struct node* fixNextPtr(struct node* root)
{
	struct node* prev;
	while(root && root->right!=null)
		root=root->right;

	while(root && root->left!=null)
	{	
		prev=root;
		root=root->left;
		root->right=prev;
	}
return root;
}

/* Tree Isomorphism Problem */

int is_isomorphic(struct node* root1,struct node* root2)
{
	if(root1==null && root2==null)
		return 1;
	if(root1!=null||root2!=null)
		return 0;
	if(root1->data!=root2->data)
		return 0;
	return (is_isomorphic(root1->left,root2->left))&&is_isomorphic(root->right,root2->right)||)is_isomorphic(root1->left,root2->right)&&is_isomorphic(root1->right,root2->left));

}

/*  Remove BST keys outside the given range   */
struct node* remove_keys_out_of_range(struct node* root,intmin,int max)
{
	if(root==null)
		return;
	root->left=remove_keys_out_of_range(root->left,min,max);
	root->right=remove_keys_out_of_range(root->right,min,max);
	if(root->data < min)
	{
		struct node* r_child=root->right;
		free(root);
		return r_child;
	}
	if(root->data > max)
	{
		struct node* l_child=root->left;
		free(root);
		return l_child;
	}
	return root;
}

/* Level Order Tree Traversal */

void print_tree(struct node* root)
{
	int h=height(root);
	int i;
	for(i=1;i<=h;i++)
	{
		level_order_traversal(root,i);
	}
}
void level_order_traversal(struct node* root,int level)
{
	if(root==null)
		return;
	if(level==1)
		printf("%d",root->data);
	else if(level > 1)
	{
		level_order_traversal(root->left,level-1);
		level_order_traversal(root->right,level-1);
	}
}

/* Using Queue Level Order Traversal */
	
void print_level_order_traversal(struct node* root)
{
	struct queue* q=createQueue(SIZE);
	struct node* temp=root;
	q.enqueue(temp->data);
	while(temp)
	{
		
		printf("%d",q.dequeue);
		if(temp->left)
		{
			q.enqueue(temp->left->data);
			temp=temp->left;
		}
		if(temp->right)
		{
			q.enqueue(temp->right->data);
			temp=temp->right;
		}
	}
}
/*UTILITY FUNCTIONS*/
struct node** createQueue(int *front, int *rear)
{
  struct node **queue =
   (struct node **)malloc(sizeof(struct node*)*MAX_Q_SIZE);  
 
  *front = *rear = 0;
  return queue;
} 
 
void enQueue(struct node **queue, int *rear, struct node *new_node)
{
  queue[*rear] = new_node;
  (*rear)++;
}     
 
struct node *deQueue(struct node **queue, int *front)
{
  (*front)++;
  return queue[*front - 1];
}     
 
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node->data = data;
  node->left = NULL;
  node->right = NULL;
 
  return(node);
}   

/* Dynamic Programming | Set 26 (Largest Independent Set Problem)  */

int lis(struct node* root)
{
	if(root==null)
		return 0;
	if(root->size)
		return root->size;
	if(root->left==null && root->right==null)
		root->size=0;
	
	int exclsv=lis(root->left) + lis(root->right);

	int iclsv=1;
	if(root->left)
		iclsv+=lis(root->left->left) + lis(root->left->right);
	if(root0>right)
		iclsv+=lis(root->right->left) + lis(root->right->right);

	root->size=max(exclsv,iclsv);
return root->size;
}

	

	
	

 